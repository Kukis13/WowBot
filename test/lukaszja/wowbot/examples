//histogram

for(Mat img : List.of(smallImage, fishImage)) {
	        	
	    
		        List<Mat> bgrPlanes = new ArrayList<>();
		        Core.split(img, bgrPlanes);
		        int histSize = 256;
		        float[] range = {0, 256}; //the upper boundary is exclusive
		        MatOfFloat histRange = new MatOfFloat(range);
		        boolean accumulate = false;
		        Mat bHist = new Mat(), gHist = new Mat(), rHist = new Mat();
		        Imgproc.calcHist(bgrPlanes, new MatOfInt(0), new Mat(), bHist, new MatOfInt(histSize), histRange, accumulate);
		        Imgproc.calcHist(bgrPlanes, new MatOfInt(1), new Mat(), gHist, new MatOfInt(histSize), histRange, accumulate);
		        Imgproc.calcHist(bgrPlanes, new MatOfInt(2), new Mat(), rHist, new MatOfInt(histSize), histRange, accumulate);
		        int histW = 512, histH = 400;
		        int binW = (int) Math.round((double) histW / histSize);
		        Mat histImage = new Mat( histH, histW, CvType.CV_8UC3, new Scalar( 0,0,0) );
		        Core.normalize(bHist, bHist, 0, histImage.rows(), Core.NORM_MINMAX);
		        Core.normalize(gHist, gHist, 0, histImage.rows(), Core.NORM_MINMAX);
		        Core.normalize(rHist, rHist, 0, histImage.rows(), Core.NORM_MINMAX);
		        float[] bHistData = new float[(int) (bHist.total() * bHist.channels())];
		        bHist.get(0, 0, bHistData);
		        float[] gHistData = new float[(int) (gHist.total() * gHist.channels())];
		        gHist.get(0, 0, gHistData);
		        float[] rHistData = new float[(int) (rHist.total() * rHist.channels())];
		        rHist.get(0, 0, rHistData);
		        for( int i = 1; i < histSize; i++ ) {
		            Imgproc.line(histImage, new Point(binW * (i - 1), histH - Math.round(bHistData[i - 1])),
		                    new Point(binW * (i), histH - Math.round(bHistData[i])), new Scalar(255, 0, 0), 2);
		            Imgproc.line(histImage, new Point(binW * (i - 1), histH - Math.round(gHistData[i - 1])),
		                    new Point(binW * (i), histH - Math.round(gHistData[i])), new Scalar(0, 255, 0), 2);
		            Imgproc.line(histImage, new Point(binW * (i - 1), histH - Math.round(rHistData[i - 1])),
		                    new Point(binW * (i), histH - Math.round(rHistData[i])), new Scalar(0, 0, 255), 2);
		        }
		        showImage(img);
		        showImage(histImage );
	        }
	        
	        
	        
	        
	        //draw marker
	        
	        			Imgproc.drawMarker(originalImage, middleOfFloat, new Scalar(130, 200, 200));
	        			
	        			
	        //
	        		        System.out.println(scoreA + " " + rect1.x + " " + rect1.y + " width = " + rect1.width + " height = " + rect1.height);
		        System.out.println(scoreB + " " + rect2.x + " " + rect2.y + " width = " + rect2.width + " height = " + rect2.height);
		        
		        
		        
		                //Imgproc.adaptiveThreshold(diff, diff, 255, Imgproc.ADAPTIVE_THRESH_GAUSSIAN_C, 1, 19, 25);

        
        int similarityPercentage = (int) ((1 - (numDiffPixels / totalPixels)) * 100);
        
        
        
        
        		Imgproc.cvtColor(diffToProcess, diffToProcess, Imgproc.COLOR_BGR2GRAY);
		Imgproc.threshold(diffToProcess, diffToProcess, 33, 255, 1);
		Utils.showImage(diffToProcess);

		List<MatOfPoint> list = new ArrayList<>();
		Mat hierarchy = new Mat();
		Imgproc.findContours(diffToProcess, list, hierarchy, Imgproc.RETR_TREE, Imgproc.CHAIN_APPROX_SIMPLE);
		Imgproc.drawContours(diffToProcess, list, -1, Scalar.all(255), 10);


		List<Rect> rectangles = list.stream().map(m -> Imgproc.boundingRect(m)).collect(Collectors.toList());
		sort(rectangles);
		Rect boundingRect = rectangles.get(0);
		boundingRect.x = boundingRect.x + VIEWPORT_X_START;
		Utils.enlargeRect(boundingRect, 10);
		
		
		
		        Mat cutImage = new Mat(oldImage, new Rect(oldImage.width() / 2, 0, oldImage.width() / 2, oldImage.height()));
        Mat cutImag2 = new Mat(newImage, new Rect(oldImage.width() / 2, 0, oldImage.width() / 2, oldImage.height()));

        Mat diff = new Mat();
        Mat greenDiff = new Mat();
		Core.subtract(cutImage, cutImag2, diff);
        Core.extractChannel(diff, greenDiff, 0);
        Core.extractChannel(diff, diff, 2);
        int greenDiffVal = (int)(Core.sumElems(greenDiff).val[0] * 1) / ((cutImag2.cols() * cutImag2.rows()));
        int redDiff = (int)(Core.sumElems(diff).val[0] * 1) / ((cutImag2.cols() * cutImag2.rows()));

        System.out.println("Red diff " + redDiff + " | Green diff " + greenDiffVal);

        
        return redDiff > 14;
	}
		        